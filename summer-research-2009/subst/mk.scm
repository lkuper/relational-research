;;; This file was generated by writeminikanren.pl
;;; Generated at 2009-04-09 12:27:22

(module mk
  (lambdaf@ lambdag@
    exist-nbr exist-cbr exist-sbr
    walk-assq walk-basic walk-rhs walk-step
    walk-sref walk-sreff walk-trie walk-fb walk-fb-opt
    walk-no-rec-stk walk-no-rec-stkf walk-pinch
    walk-pinch-s walk-foldr walk-bst walk-skew walk-skew-def
    safe-walk-s safe-walk-pinch
    unify-var-sv unify-var-mv unify-check-sv unify-check-mv unify-sv unify-mv
    ext-s-sl ext-s-dl ext-s-t ext-s-bst ext-s-skew-init ext-s-skew ext-s-kd
    ext-s-init size-s
    run* rhs lhs var-1 var-2 var-2-skew var-2-skew-def var-bst var var?
    empty-s ext-s-check occurs-check
    walk* reify-s reify-name reify ==-check mzero inc unit choice
    case-inf run take == bind* bind unify ==/var empty-s-l
    conde mplus* mplus conda ifa condu ifu project succeed fail
    walk exist ext-s safe-walk unify-var unify-check unify-safe)
  (import (scheme) (mkstats) (settings) (trie) (bst) (skew-bral) (skew-bral-def))

  (define-syntax lambdag@
    (syntax-rules ()
      ((_ (p) e) (lambda (p) e))))

  (define-syntax lambdaf@
    (syntax-rules ()
      ((_ () e) (lambda () e))))

  (define-syntax run*
    (syntax-rules ()
      ((_ (x) g ...) (run #f (x) g ...))))

  (define-syntax rhs
    (syntax-rules ()
      ((_ x) (cdr x))))

  (define-syntax lhs
    (syntax-rules ()
      ((_ x) (car x))))

  (define-syntax size-s-l
    (syntax-rules ()
      ((_ x) (length x))))
  (define-syntax size-s-t
    (syntax-rules ()
      ((_ x) (t:size x))))
  (define-syntax size-s-bst
    (syntax-rules ()
      ((_ x) (bst:size x))))
  (define-syntax size-s-skew
    (syntax-rules ()
      ((_ x) (k:size x))))
  (define-syntax size-s-skew-def
    (syntax-rules ()
      ((_ x) (kd:size x))))

  (define var-1
    (lambda (x)
      (vector x)))

  (define var-bst
    (lambda (x)
      (set! var-counter (add1 var-counter))
      (vector x (bst:hash var-counter))))

  (define var-counter -1)
  (define var-2
    (lambda (x)
      (set! var-counter (add1 var-counter))
      (vector x var-counter)))
  (define var-2-skew
    (lambda (x)
      (vector x -1)))
  (define var-2-skew-def
    (lambda (x s)
      ;;(let ((r (vector x (kd:reserve s))))
      ;;(printf "here - ~s\n" r)
      ;;r)))
      (vector x (kd:reserve s))))

  (define var-idx
    (lambda (x)
      (vector-ref x 1)))

  (define-syntax var?
    (syntax-rules ()
      ((_ x) (vector? x))))

  (define empty-s-l
    (lambda ()
      '()))

;;;----------------------------------------------------------
;;; Various versions of walk for comparison testing.
;;;----------------------------------------------------------

  ;;-- O(n^2) algorithms ---------------------------------------

  ;; assq-based - simplest
  (define walk-assq
    (lambda (v s)
      (cond
        ((var? v)
         (let ((a (assq v s)))
           (cond
             (a (walk-assq (rhs a) s))
             (else v))))
        (else v))))

  ;; basic walk with no checks (like assq but doesn't use built-in)
  (include "walk-basic.scm")
;  (define walk-basic
;    (lambda (v s^)
;      (inc-ws-calls s^)
;      (let loop ((s s^))
;        (inc-ws-steps)
;        (cond
;          ((var? v)
;           (cond
;             ((null? s) v)
;             ((eq? v (lhs (car s))) (begin (inc-ws-recrs)
;                                           (ws-found-match)
;                                           (walk-basic (rhs (car s)) s^)))
;             (else (loop (cdr s)))))
;          (else v)))))

  ;; like walk-basic but adds check for v on rhs
  (define walk-rhs
    (lambda (v s^)
      (inc-ws-calls s^)
      (let loop ((s s^))
        (inc-ws-steps)
        (cond
          ((var? v)
           (cond
             ((null? s) v)
             ((eq? v (rhs (car s))) v)
             ((eq? v (lhs (car s))) (begin (inc-ws-recrs)
                                           (ws-found-match)
                                           (walk-rhs (rhs (car s)) s^)))
             (else (loop (cdr s)))))
          (else v)))))

  ;; like walk-rhs but after first match on lhs uses auxillary function 'step'
  ;; to search the rhs because a match is guaranteed
  (define walk-step
    (lambda (v s^)
      (inc-ws-calls s^)
      (let loop ((s s^))
        (inc-ws-steps)
        (cond
          ((var? v)
           (cond
             ((null? s) v)
             ((eq? v (rhs (car s))) v)
             ((eq? v (lhs (car s))) (step (rhs (car s)) s^))
             (else (loop (cdr s)))))
          (else v)))))
;  (define step
;    (lambda (v s^)
;      (inc-ws-recrs)
;      (ws-found-match)
;      (let loop ((s s^))
;        (inc-ws-steps)
;        (cond
;          ((var? v)
;           (cond
;             ((eq? v (rhs (car s))) v)
;             ((eq? v (lhs (car s))) (step (rhs (car s)) s^))
;             (else (loop (cdr s)))))
;          (else v)))))

  ;; like walk-step but uses substitution reference as variable birth record
  (include "walk-sref.scm")
;  (define walk-sref
;    (lambda (v s^)
;      (inc-ws-calls s^)
;      (let loop ((s s^))
;        (inc-ws-steps)
;        (cond
;          ((var? v)
;           (cond
;             ((null? s) v) ;; XXX
;             ((eq? s (vector-ref v 0)) v)
;             ((eq? v (rhs (car s))) v)
;             ((eq? v (lhs (car s))) (step (rhs (car s)) s^))
;             (else (loop (cdr s)))))
;          (else v)))))

  ;; like walk-sref but extends (and returns) substitution when a non-variable is
  ;; found to flatten chains
  (define walk-sreff
    (lambda (v s^)
      (inc-ws-calls s^)
      (let loop ([s s^])
        (inc-ws-steps)
        (cond
          ((var? v)
           (cond
             ((null? s) (values v s^)) ;; XXX
             ((eq? s (vector-ref v 0)) (values v s^))
             ((eq? v (rhs (car s))) (values v s^))
             ((eq? v (lhs (car s))) (step-sreff (rhs (car s)) `(,v) s^))
             (else (loop (cdr s)))))
          (else (values v s^))))))
  (define ret-sreff
    (lambda (v m s)
      (let loop ([m m] [s s])
        (cond
          [(null? m) (values v s)]
          [else (loop (cdr m) (cons `(,(car m) . ,v) s))]))))
  (define step-sreff
    (lambda (v m s^)
      (inc-ws-recrs)
      (ws-found-match)
      (let loop ((s s^))
        (inc-ws-steps)
        (cond
          ((var? v)
           (cond
             ((eq? v (rhs (car s))) (values v s^))
             ((eq? v (lhs (car s))) (step-sreff (rhs (car s)) (cons v m) s^))
             (else (loop (cdr s)))))
          (else (ret-sreff v m s^))))))

  ;; general but fast/safe single-linked walk - must check for null s, uses but
  ;; doesn't rely on subst-ref birth records
  (define safe-step
    (lambda (v s^)
      (inc-ws-safe-recrs)
      (let loop ((s s^))
        (inc-ws-safe-steps)
        (cond
          ((var? v)
           (cond
             ((eq? v (rhs (car s))) v)
             ((eq? v (lhs (car s))) (safe-step (rhs (car s)) s^))
             (else (loop (cdr s)))))
          (else v)))))
  (define safe-walk-s
    (lambda (v s^)
      (inc-ws-safe-calls)
      (let loop ((s s^))
        (inc-ws-safe-steps)
        (cond
          ((null? s) v)
          ((var? v)
           (cond
             ((eq? s (vector-ref v 0)) v)
             ((eq? v (rhs (car s))) v)
             ((eq? v (lhs (car s))) (safe-step (rhs (car s)) s^))
             (else (loop (cdr s)))))
          (else v)))))

  ;;-- O(n) algorithms -----------------------------------------

  ;; trie-based association
  (define walk-trie
    (lambda (v s)
      (inc-ws-calls s)
      (inc-ws-steps)
      (cond
        ((var? v)
         (cond
           ((t:lookup (var-idx v) s) =>
            (lambda (a)
              (walk-trie (t:binding-value a) s)))
           (else v)))
        (else v))))

  ;; bst-based association
  (define walk-bst
    (lambda (v s)
      (cond
        ((var? v)
         (let ((a (bst:lookup (vector-ref v 1) s)))
           (cond
             ((not (eq? a 'DE)) (walk-bst a s))
             (else v))))
        (else v))))

  ;; walk based on skew binary random access lists
  (define walk-skew
    (lambda (v s)
      (inc-ws-calls s)
      (inc-ws-steps)
      (cond
        ((var? v)
         (cond
           ((k:lookup (var-idx v) s) =>
            (lambda (a)
              (let [(a (k:get-value a))]
                (cond
                  [(eq? v a) v]
                  [else (walk-skew a s)]))))
           (else v)))
        (else v))))

  ;; like walk skew but defer extensions as long as possible
  (define walk-skew-def
    (lambda (v s)
      (inc-ws-calls s)
      (inc-ws-steps)
      (cond
        ((var? v)
         (cond
           ((kd:lookup (var-idx v) s) =>
            (lambda (a)
              (walk-skew-def (kd:get-value a) s)))
           (else v)))
        (else v))))

  ;; walk that uses stack-unrolling to reverse the direction of the walk after
  ;; the first match, so at most goes forward through the list, then backward
  ;; O(2n)
  (load "walk-front-back.scm")
;  (define walk-fb
;    (lambda (v s^)
;      (inc-ws-calls s^)
;      (call/cc
;       (lambda (k)
;         (let loop ((s s^))
;           (inc-ws-steps)
;           (cond
;             ((var? v)
;              (cond
;                ((null? s) v) ;; XXX
;                ((eq? s (vector-ref v 0)) (k v))
;                ((eq? v (rhs (car s))) (k v))
;                ((eq? v (lhs (car s))) (rhs (car s)))
;                (else
;                 (let ([v (loop (cdr s))])
;                   (inc-ws-steps)
;                   (ws-found-match)
;                   (cond
;                     ((var? v)
;                      (cond
;                        ((eq? v (lhs (car s))) (rhs (car s)))
;                        (else v)))
;                     (else (k v)))))))
;             (else (k v))))))))

  ;; same as walk-fb but optimized
  (define walk-fb-opt
    (lambda (t s)
      (inc-ws-calls s)
      (call/cc
       (lambda (k)
         (let rec ((s s))
           (let-syntax
               ((T^ (syntax-rules ()
                      ((_ t c fk)
                       (cond
                         ((or (not (var? t)) . c) (k t))
                         ((eq? t (caar s)) (cdar s))
                         (else fk))))))
             (T^ t
                 ((null? s) ;; XXX
                  (eq? s (vector-ref t 0))
                  (and (var? (cdar s))
                       (eq? (cdar s) t)))
                 (let ((t (rec (cdr s))))
                   (inc-ws-steps)
                   (ws-found-match)
                   (T^ t () t)))))))))

  ;; same as walk-fb but builds reverse list on the way forward instead of using
  ;; stack unrolling to walk backward. Doesn't use double-linked list assoc.
  (include "walk-flatten.scm")
;  (define walk-no-rec-stk
;    (lambda (v s^)
;      (inc-ws-calls s^)
;      (let loop ([s s^] [s< '()])
;        (inc-ws-steps)
;        (cond
;          ((var? v)
;           (cond
;             ((null? s) v) ;; XXX
;             ((eq? s (vector-ref v 0)) v)
;             ((eq? v (rhs (car s))) v)
;             ((eq? v (lhs (car s))) (walk-no-rec-stk-back (rhs (car s)) s<))
;             ;;((eq? v (lhs (car s))) (if (null? s<) (rhs (car s)) (walk-no-rec-stk-back (rhs (car s)) s<)))
;             (else (loop (cdr s) (cons (car s) s<)))))
;          (else v)))))
;  (define walk-no-rec-stk-back
;    (lambda (v s)
;      (ws-found-match)
;      (inc-ws-steps)
;      (cond
;        ((var? v)
;         (cond
;           ((null? s) v) ;; why do we need this?
;           ((eq? v (lhs (car s))) (walk-no-rec-stk-back (rhs (car s)) (cdr s)))
;           (else (walk-no-rec-stk-back v (cdr s)))))
;        (else v))))

  ;; same as walk-no-rec-stk but flattens chains like walk-sreff  
  (include "walk-flatten.scm")
;  (define walk-no-rec-stkf
;    (lambda (v s^)
;      (inc-ws-calls s^)
;      (let loop ([s s^] [s< '()])
;        (inc-ws-steps)
;        (cond
;          ((var? v)
;           (cond
;             ((null? s) (values v s^)) ;; XXX
;             ((eq? s (vector-ref v 0)) (values v s^))
;             ((eq? v (rhs (car s))) (values v s^))
;             ((eq? v (lhs (car s))) (walk-no-rec-stkf-back (rhs (car s)) `(,v) s^ s<))
;             (else (loop (cdr s) (cons (car s) s<)))))
;          (else (values v s^))))))
;  (define ret-no-rec-stkf
;    (lambda (v m s)
;      (let loop ([m m] [s s])
;        (cond
;          [(null? m) (values v s)]
;          [else (loop (cdr m) (cons `(,(car m) . ,v) s))]))))
;  (define walk-no-rec-stkf-back
;    (lambda (v m s> s)
;      (ws-found-match)
;      (inc-ws-steps)
;      (cond
;        ((var? v)
;         (cond
;           ((null? s) (values v s>)) ;; why do we need this?
;           ((eq? v (lhs (car s)))
;            (walk-no-rec-stkf-back (rhs (car s)) (cons v m) s> (cdr s)))
;           (else (walk-no-rec-stkf-back v m s> (cdr s)))))
;        (else (ret-no-rec-stkf v m s>)))))

  ;; same as walk-fb except instead of simply walking backward after the first
  ;; match, it ping-pongs back and forth between the front and back of the list,
  ;; shrinking the current search "window". In order to do this it uses a double-
  ;; linked list representation for associations and builds the back-wards chain
  ;; dynamically as it traverses forward looking for the first match. The
  ;; backwards chain cannot be set at the time the association is extended because
  ;; in the backwards direction the association is a tree.
  (define walk-pinch
    (lambda (v s^)
      (inc-ws-calls s^)
      (if (not (null? s^))
          (set-cdr! (car s^) #f))
      (let loop ((s s^))
        (inc-ws-steps)
        (cond
          ((var? v)
           (cond
             ((null? s) v) ;; XXX
             ((eq? s (vector-ref v 0)) v)
             ((eq? v (rhs (caar s))) v)
             ((eq? v (lhs (caar s))) (pinch (rhs (caar s)) s^ (cdar s)))
             (else (begin
                     (if (not (null? (cdr s)))
                         (set-cdr! (cadr s) (car s)))
                     (loop (cdr s))))))
          (else v)))))
  (define pinch
    (lambda (v s>^ s<^)
      (ws-found-match)
      (let loop ((s> s>^) (s< s<^))
        (inc-ws-steps)
        (cond
          ((equal? #f s<) v)
          ((var? v)
           (cond
             ;; ->
             ((eq? s> (vector-ref v 0)) v)
             ((eq? v (rhs (caar s>))) v)
             ((eq? v (lhs (caar s>))) (pinch (rhs (caar s>)) s>^ (cdar s>)))
             ;; <-
             ((eq? v (lhs (car s<))) (pinch (rhs (car s<)) s>^ (cdr s<)))
             (else (loop (cdr s>) (cdr s<)))))
          (else v)))))

  ;; support functions needed for double-linked substitutions
  (define safe-walk-pinch
    (lambda (v s^)
      (inc-ws-safe-calls)
      (let loop ((s s^))
        (inc-ws-safe-steps)
        (cond
          ((var? v)
           (cond
             ((null? s) v)
             ((eq? s (vector-ref v 0)) v)
             ((eq? v (rhs (caar s))) v)
             ((eq? v (lhs (caar s))) (begin (inc-ws-safe-recrs)
                                            (safe-walk-pinch (rhs (caar s)) s^)))
             (else (loop (cdr s)))))
          (else v)))))

  ;; same as walk-pinch but uses single-linked reversed list built at run time
  (include "walk-pinch.scm")
;  (define walk-pinch-s
;    (lambda (v s^)
;      (inc-ws-calls s^)
;      (let loop ((s s^) (s< '()))
;        (inc-ws-steps)
;        (cond
;          ((var? v)
;           (cond
;             ((null? s) v) ;; XXX
;             ((eq? s (vector-ref v 0)) v)
;             ((eq? v (rhs (car s))) v)
;             ((eq? v (lhs (car s))) (pinch-s (rhs (car s)) s^ s<))
;             (else (loop (cdr s) (cons (car s) s<)))))
;          (else v)))))
;  (define pinch-s-find
;    (lambda (e s)
;      (cond
;        [(eq? e (car s)) (cdr s)]
;        [else (pinch-s-find e (cdr s))])))
;  (define pinch-s
;    (lambda (v s>^ s<^)
;      (ws-found-match)
;      (let loop ((s> s>^) (s< s<^))
;        (inc-ws-steps)
;        (cond
;          ((null? s<) v)
;          ((var? v)
;           (cond
;             ;; ->
;             ((eq? s> (vector-ref v 0)) v)
;             ((eq? v (rhs (car s>))) v)
;             ((eq? v (lhs (car s>))) (pinch-s (rhs (car s>)) s>^ (pinch-s-find (car s>) s<)))
;             ;; <-
;             ((eq? v (lhs (car s<))) (pinch-s (rhs (car s<)) s>^ (cdr s<)))
;             (else (loop (cdr s>) (cdr s<)))))
;          (else v)))))

  ;; walk using the foldr metaphor
  (define-syntax test-var?!
    (syntax-rules ()
      ((_ exit exp) (let ((value exp)) (if (var? value) value (exit value))))))

  (define foldr/k
    (lambda (init ls exit) ;; ls^ could be passed in from walk, see below comments.
      (cond
        ((null? ls) (exit init))  ;; (eq? ls^ ls), which could be via else clause (fold/k (vector-ref v 0) v s exit) from walk.
        (else
         (let ((a (car ls)))
           (inc-ws-steps)
           (cond
             ((eqv? (rhs a) init) (exit init))
             ((eqv? (lhs a) init) (test-var?! exit (rhs a)))
             (else (let ((init (foldr/k init (cdr ls) exit))) ;;; add ls^ as first argument to foldr/k
                     (inc-ws-steps)
                     (cond
                       ((eqv? (lhs a) init) (test-var?! exit (rhs a)))
                       (else init))))))))))

  (define walk-foldr
    (lambda (v s)
      (inc-ws-calls s)
      (cond
        ((not (var? v)) v)
        (else (call/cc (lambda (exit) (foldr/k v s exit)))))))

  ;;-------------------------------------------------------------------
  (define ext-s-sl
    (lambda (x v s)
      (cons `(,x . ,v) s)))
  (define ext-s-dl
    (lambda (x v s)
      (cons `((,x . ,v) . #f) s)))
  (define ext-s-t
    (lambda (x v s)
      (t:bind (var-idx x) v s)))
  (define ext-s-bst
    (lambda (x v s)
      (bst:ext (vector-ref x 1) v s)))
  (define ext-s-skew
    (lambda (x v s)
      (k:update (var-idx x) v s)))
  (define ext-s-skew-init
    (lambda (x v s)
      (vector-set! x 1 (car s))
      (k:associate v s)))
  (define ext-s-kd
    (lambda (x v s)
      (kd:associate (var-idx x) v s)))

  (define unify-check-sv
    (lambda (u v s)
      (let ((u (walk u s))
            (v (walk v s)))
        ;;(let ((u (safe-walk u s))
        ;;(v (safe-walk v s)))
        (cond
          ((eq? u v) s)
          ((var? u) (ext-s-check u v s))
          ((var? v) (ext-s-check v u s))
          ((and (pair? u) (pair? v))
           (let ((s (unify-check-sv
                     (car u) (car v) s)))
             (and s (unify-check-sv
                     (cdr u) (cdr v) s))))
          ((equal? u v) s)
          (else #f)))))
  (define unify-check-mv
    (lambda (u v s)
      (let*-values ([(u s^) (walk u s)]
                    [(v s) (walk v s^)])
        ;;(let ((u (safe-walk u s))
        ;;(v (safe-walk v s)))
        (cond
          ((eq? u v) s)
          ((var? u) (ext-s-check u v s))
          ((var? v) (ext-s-check v u s))
          ((and (pair? u) (pair? v))
           (let ((s (unify-check-mv
                     (car u) (car v) s)))
             (and s (unify-check-mv
                     (cdr u) (cdr v) s))))
          ((equal? u v) s)
          (else #f)))))

  (define ext-s-check
    (lambda (x v s)
      (cond
        ((occurs-check x v s) #f)
        (else (ext-s x v s)))))

  (define occurs-check
    (lambda (x v s)
      (let ((v (safe-walk v s)))
        (cond
          ((var? v) (eq? v x))
          ((pair? v)
           (or
            (occurs-check x (car v) s)
            (occurs-check x (cdr v) s)))
          (else #f)))))

  (define walk*
    (lambda (w s)
      (let ((v (safe-walk w s)))
        (cond
          ((var? v) v)
          ((pair? v)
           (cons
            (walk* (car v) s)
            (walk* (cdr v) s)))
          (else v)))))

  (define reify-s
    (lambda (v s)
      (let ((v (safe-walk v s)))
        (cond
          ((var? v)
           (ext-s v (reify-name (size-s s)) s))
          ((pair? v) (reify-s (cdr v)
                              (reify-s (car v) s)))
          (else s)))))

  (define reify-name
    (lambda (n)
      (string->symbol
       (string-append "_" "." (number->string n)))))

  ;;(define reify
  ;;(lambda (v s)
  ;;(let ((v (walk* v s)))
  ;;(walk* v (reify-s v (empty-s))))))
  (define rc -1)
  (define rl '())
  (define reify
    (lambda (v s)
      (set! rc -1)
      (set! rl '())
      (let loop [(v v)]
        (let ((v (safe-walk v s)))
          (cond
            ((assq v rl) => (lambda (a) (cdr a)))
            ((var? v) (begin (set! rc (add1 rc))
                             (let [(n (cons v (reify-name rc)))]
                               (set! rl (cons n rl))
                               (cdr n))))
            ((pair? v)
             (let [(c (loop (car v)))]
               (cons c (loop (cdr v)))))
            (else v))))))

  (define ==-check
    (lambda (v w)
      (lambdag@ (a)
        (unify-check v w a))))

  (define-syntax mzero
    (syntax-rules () ((_) #f)))
  (define-syntax inc
    (syntax-rules () ((_ e) (lambdaf@ () e))))
  (define-syntax unit
    (syntax-rules () ((_ a) a)))
  (define-syntax choice
    (syntax-rules () ((_ a f) (cons a f))))

  (define-syntax case-inf
    (syntax-rules ()
      ((_ e (() e0) ((f^) e1) ((a^) e2) ((a f) e3))
       (let ((a-inf e))
         (cond
           ((not a-inf) e0)
           ((procedure? a-inf)  (let ((f^ a-inf)) e1))
           ((not (and (pair? a-inf)
                      (procedure? (cdr a-inf))))
            (let ((a^ a-inf)) e2))
           (else (let ((a (car a-inf)) (f (cdr a-inf)))
                   e3)))))))

  (define-syntax run
    (syntax-rules ()
      ((_ n (x) g0 g ...)
       (take n
             (lambdaf@ ()
               ((exist (x) g0 g ...
                       (lambdag@ (a)
                         (cons (reify x a) '())))
                (empty-s)))))))

  (define take
    (lambda (n f)
      (if (and n (zero? n))
          '()
          (case-inf (f)
                    (() '())
                    ((f) (take n f))
                    ((a) a)
                    ((a f)
                     (cons (car a)
                           (take (and n (- n 1)) f)))))))

  (define ==
    (lambda (u v)
      (lambdag@ (a)
        (unify u v a))))

  (define-syntax exist-nbr
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (s)
         (inc
          (let ((x (var 'x s)) ...)
            (bind* (g0 s) g ...)))))))

  (define-syntax exist-cbr
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (s)
         (inc
          (let ((x (var 'x s)) ...)
            (let* ((s (ext-s-init x x s)) ...)
              (bind* (g0 s) g ...))))))))

  (define-syntax exist-sbr
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (a)
         (inc
          (let ((x (var a s)) ...)
            (bind* (g0 a) g ...)))))))

  (define-syntax bind*
    (syntax-rules ()
      ((_ e) e)
      ((_ e g0 g ...) (bind* (bind e g0) g ...))))

  (define bind
    (lambda (a-inf g)
      (case-inf a-inf
                (() (mzero))
                ((f) (inc (bind (f) g)))
                ((a) (g a))
                ((a f) (mplus (g a) (lambdaf@ () (bind (f) g)))))))

  (define-syntax conde
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (a)
         (inc
          (mplus*
           (bind* (g0 a) g ...)
           (bind* (g1 a) g^ ...) ...))))))

  (define-syntax mplus*
    (syntax-rules ()
      ((_ e) e)
      ((_ e0 e ...) (mplus e0
                           (lambdaf@ () (mplus* e ...))))))

  (define mplus
    (lambda (a-inf f)
      (case-inf a-inf
                (() (f))
                ((f^) (inc (mplus (f) f^)))
                ((a) (choice a f))
                ((a f^) (choice a (lambdaf@ () (mplus (f) f^)))))))

  (define-syntax conda
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (a)
         (inc
          (ifa ((g0 a) g ...)
               ((g1 a) g^ ...) ...))))))

  (define-syntax ifa
    (syntax-rules ()
      ((_) (mzero))
      ((_ (e g ...) b ...)
       (let loop ((a-inf e))
         (case-inf a-inf
                   (() (ifa b ...))
                   ((f) (inc (loop (f))))
                   ((a) (bind* a-inf g ...))
                   ((a f) (bind* a-inf g ...)))))))

  (define-syntax condu
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (a)
         (inc
          (ifu ((g0 a) g ...)
               ((g1 a) g^ ...) ...))))))

  (define-syntax ifu
    (syntax-rules ()
      ((_) (mzero))
      ((_ (e g ...) b ...)
       (let loop ((a-inf e))
         (case-inf a-inf
                   (() (ifu b ...))
                   ((f) (inc (loop (f))))
                   ((a) (bind* a-inf g ...))
                   ((a f) (bind* (unit a) g ...)))))))

  (define-syntax project
    (syntax-rules ()
      ((_ (x ...) g g* ...)
       (lambdag@ (s)
         (let ((x (walk* x s)) ...)
           ((exist () g g* ...) s))))))

  (define succeed (== #f #f))

  (define fail (== #f #t))

  (define onceo
    (lambda (g)
      (condu
        (g succeed)
        (else fail)))) ;;<< why does the 'else' fail in ikarus?

  ;;(define ==/var
  ;;(lambda (u v)
  ;;(lambdag@ (a)
  ;;(unify-var u v a))))
  (define ==/var ;; dangerous - don't use generally
    (lambda (u v)
      (lambdag@ (a)
        (ext-s u v a))))

  (define unify-var-sv
    (lambda (v w s)
      (let ((w (walk w s)))
        (cond
          ((eq? v w) s)
          (else (ext-s v w s))))))
  (define unify-var-mv
    (lambda (v w s)
      (let-values ([(w s) (walk w s)])
        (cond
          ((eq? v w) s)
          (else (ext-s v w s))))))

  (inlude "unify.scm")
;  (define unify-sv
;    (lambda (v w s)
;      (let ((v (walk v s))
;            (w (walk w s)))
;        (cond
;          ((eq? v w) s)
;          ((var? v) (ext-s v w s))
;          ;;((var? v) ;; ordering testing
;          ;;(if (and (var? w)
;          ;;(fx< (fxabs (fx- (var-idx w) (cadr s)))
;          ;;(fxabs (fx- (var-idx v) (cadr s)))))
;          ;;(ext-s w v s)
;          ;;(ext-s v w s)))
;          ((var? w) (ext-s w v s))
;          ((and (pair? v) (pair? w))
;           (let ((s (unify-sv (car v) (car w) s)))
;             (and s (unify-sv (cdr v) (cdr w) s))))
;          ((equal? v w) s)
;          (else #f)))))
  (define unify-mv
    (lambda (v w s)
      (let*-values ([(v s^) (walk v s)]
                    [(w s) (walk w s^)])
        (cond
          ((eq? v w) s)
          ((var? v) (ext-s v w s))
          ((var? w) (ext-s w v s))
          ((and (pair? v) (pair? w))
           (let ((s (unify-mv (car v) (car w) s)))
             (and s (unify-mv (cdr v) (cdr w) s))))
          ((equal? v w) s)
          (else #f)))))

  (define unify-safe
    (lambda (v w s)
      (let ((v (safe-walk v s))
            (w (safe-walk w s)))
        (cond
          ((eq? v w) s)
          ((var? v) (ext-s v w s))
          ((var? w) (ext-s w v s))
          ((and (pair? v) (pair? w))
           (let ((s (unify-safe (car v) (car w) s)))
             (and s (unify-safe (cdr v) (cdr w) s))))
          ((equal? v w) s)
          (else #f)))))

  ;;-------------------------------------------------------------------
  ;; choose versions of various functions/macros
  (define-syntax walk
    (syntax-rules ()
      [(_ v s) ((choose-walk walk-assq walk-basic walk-rhs walk-step
                             walk-sref walk-sreff walk-trie walk-bst walk-skew
                             walk-skew-def walk-fb walk-fb-opt
                             walk-no-rec-stk walk-no-rec-stkf walk-pinch
                             walk-pinch-s walk-foldr) v s)]))
  (define-syntax exist
    (syntax-rules ()
      [(_ v* g0 g ...) (choose-birth-record
                        (exist-nbr v* g0 g ...)
                        (exist-cbr v* g0 g ...)
                        (exist-sbr v* g0 g ...))]))
  (define-syntax var
    (syntax-rules ()
      [(_ x s)
       (choose-var (var-1 x)
                   (var-2 x)
                   (var-2-skew x)
                   (var-2-skew-def x s)
                   (var-bst x))]))

  (define-syntax empty-s
    (syntax-rules ()
      [(_) ((choose-assoc-repr empty-s-l empty-s-l empty-s-l bst:empty
                               k:empty kd:empty))]))
  (define-syntax ext-s
    (syntax-rules ()
      [(_ x v s) ((choose-assoc-repr ext-s-sl ext-s-dl ext-s-t ext-s-bst
                                     ext-s-skew ext-s-kd) x v s)]))
  (define-syntax ext-s-init
    (syntax-rules ()
      [(_ x v s) ((choose-assoc-repr ext-s-sl ext-s-dl ext-s-t ext-s-bst
                                     ext-s-skew-init ext-s-kd) x v s)]))
  (define-syntax size-s
    (syntax-rules ()
      [(_ s) (choose-size-s (size-s-l s) (size-s-t s) (size-s-bst s)
                            (size-s-skew s) (size-s-skew-def s))]))
  (define-syntax safe-walk
    (syntax-rules ()
      [(_ v s) ((choose-assoc-repr safe-walk-s safe-walk-pinch
                                   walk-trie walk-bst walk-skew walk-skew-def) v s)]))
  (define-syntax unify-var
    (syntax-rules ()
      [(_ v w s) ((choose-walk-return unify-var-sv unify-var-mv) v w s)]))
  (define-syntax unify-check
    (syntax-rules ()
      [(_ u v s) ((choose-walk-return unify-check-sv unify-check-mv) u v s)]))
  (define-syntax unify
    (syntax-rules ()
      [(_ v w s) ((choose-walk-return unify-sv unify-mv) v w s)]))
  )
